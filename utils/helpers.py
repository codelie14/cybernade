"""
Helper functions for CYBERNADE.
"""
import os
import logging
import time
import json
from datetime import datetime
import csv

def get_timestamp():
    """Get a formatted timestamp for the current time.
    
    Returns:
        str: Formatted timestamp
    """
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def ensure_directory_exists(file_path):
    """Ensure the directory for the given file path exists.
    
    Args:
        file_path (str): Path to the file
        
    Returns:
        bool: True if directory exists or was created, False otherwise
    """
    directory = os.path.dirname(file_path)
    
    if not directory:
        return True
    
    if not os.path.exists(directory):
        try:
            os.makedirs(directory, exist_ok=True)
            return True
        except Exception as e:
            logging.error(f"Failed to create directory {directory}: {e}")
            return False
    
    return True

def export_to_file(data, file_path, file_format="txt"):
    """Export data to a file.
    
    Args:
        data (dict): Data to export
        file_path (str): Path to the output file
        file_format (str): Format of the output file (txt, csv, json)
        
    Returns:
        bool: True if export successful, False otherwise
    """
    # Ensure directory exists
    if not ensure_directory_exists(file_path):
        return False
    
    try:
        if file_format.lower() == "txt":
            return _export_to_txt(data, file_path)
        elif file_format.lower() == "csv":
            return _export_to_csv(data, file_path)
        elif file_format.lower() == "json":
            return _export_to_json(data, file_path)
        else:
            logging.error(f"Unsupported export format: {file_format}")
            return False
    except Exception as e:
        logging.error(f"Export error: {e}")
        return False

def _export_to_txt(data, file_path):
    """Export data to a text file.
    
    Args:
        data (dict): Data to export
        file_path (str): Path to the output file
        
    Returns:
        bool: True if export successful, False otherwise
    """
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            # If data is a string, write it directly
            if isinstance(data, str):
                f.write(data)
                return True
            
            # Get target type
            target_type = data.get("type", "unknown")
            
            # Write header
            if target_type == "ip":
                f.write(f"=== OSINT Results for IP: {data.get('target')} ===\n\n")
            elif target_type == "domain":
                f.write(f"=== OSINT Results for Domain: {data.get('target')} ===\n\n")
            elif target_type == "email":
                f.write(f"=== OSINT Results for Email: {data.get('target')} ===\n\n")
            else:
                f.write(f"=== OSINT Results for {data.get('target')} ===\n\n")
            
            # Write timestamp and execution time
            f.write(f"Timestamp: {data.get('timestamp', 'N/A')}\n")
            f.write(f"Execution time: {data.get('execution_time', 0):.2f} seconds\n\n")
            
            # Write results based on target type
            if target_type == "ip":
                _write_ip_results(f, data)
            elif target_type == "domain":
                _write_domain_results(f, data)
            elif target_type == "email":
                _write_email_results(f, data)
            else:
                # Write raw data for unknown types
                f.write(json.dumps(data, indent=2))
            
            # Write footer
            f.write("\n\n=== End of Report ===\n")
            f.write(f"Generated by CYBERNADE on {get_timestamp()}\n")
            
            return True
    except Exception as e:
        logging.error(f"Text export error: {e}")
        return False

def _write_ip_results(f, data):
    """Write IP results to a text file.
    
    Args:
        f (file): File object
        data (dict): Data to export
    """
    # Write geolocation information
    geo = data.get("geolocation", {})
    f.write("=== Geolocation Information ===\n")
    
    if "error" in geo:
        f.write(f"Error: {geo['error']}\n")
    else:
        f.write(f"City: {geo.get('city', 'N/A')}\n")
        f.write(f"Region: {geo.get('region', 'N/A')}\n")
        f.write(f"Country: {geo.get('country', 'N/A')}\n")
        f.write(f"Postal: {geo.get('postal', 'N/A')}\n")
        f.write(f"Latitude: {geo.get('latitude', 'N/A')}\n")
        f.write(f"Longitude: {geo.get('longitude', 'N/A')}\n")
        f.write(f"ASN: {geo.get('asn', 'N/A')}\n")
        f.write(f"Organization: {geo.get('org', 'N/A')}\n")
        f.write(f"Timezone: {geo.get('timezone', 'N/A')}\n")
    
    # Write Shodan information
    shodan = data.get("shodan", {})
    f.write("\n=== Shodan Information ===\n")
    
    if "error" in shodan:
        f.write(f"Error: {shodan['error']}\n")
    else:
        f.write(f"Hostnames: {', '.join(shodan.get('hostnames', ['N/A']))}\n")
        f.write(f"Country: {shodan.get('country', 'N/A')}\n")
        f.write(f"City: {shodan.get('city', 'N/A')}\n")
        f.write(f"Organization: {shodan.get('org', 'N/A')}\n")
        f.write(f"ISP: {shodan.get('isp', 'N/A')}\n")
        f.write(f"ASN: {shodan.get('asn', 'N/A')}\n")
        f.write(f"Operating System: {shodan.get('os', 'N/A')}\n")
        f.write(f"Open Ports: {', '.join(map(str, shodan.get('ports', ['N/A'])))}\n")
        f.write(f"Vulnerabilities: {', '.join(shodan.get('vulns', ['None']))}\n")
        f.write(f"Last Update: {shodan.get('last_update', 'N/A')}\n")
        f.write(f"Tags: {', '.join(shodan.get('tags', ['None']))}\n")

def _write_domain_results(f, data):
    """Write domain results to a text file.
    
    Args:
        f (file): File object
        data (dict): Data to export
    """
    # Write IP information
    f.write(f"IP: {data.get('ip', 'N/A')}\n\n")
    
    # Write WHOIS information
    whois_data = data.get("whois", {})
    f.write("=== WHOIS Information ===\n")
    
    if "error" in whois_data:
        f.write(f"Error: {whois_data['error']}\n")
    else:
        f.write(f"Registrar: {whois_data.get('registrar', 'N/A')}\n")
        f.write(f"Creation Date: {whois_data.get('creation_date', 'N/A')}\n")
        f.write(f"Expiration Date: {whois_data.get('expiration_date', 'N/A')}\n")
        f.write(f"Updated Date: {whois_data.get('updated_date', 'N/A')}\n")
        f.write(f"Name Servers: {', '.join(whois_data.get('name_servers', ['N/A']))}\n")
        f.write(f"Status: {', '.join(whois_data.get('status', ['N/A']))}\n")
        f.write(f"DNSSEC: {whois_data.get('dnssec', 'N/A')}\n")
        
        # Write registrant information
        registrant = whois_data.get("registrant", {})
        f.write("\nRegistrant Information:\n")
        f.write(f"  Name: {registrant.get('name', 'N/A')}\n")
        f.write(f"  Organization: {registrant.get('organization', 'N/A')}\n")
        f.write(f"  Country: {registrant.get('country', 'N/A')}\n")
    
    # Write DNS information
    dns_data = data.get("dns", {})
    f.write("\n=== DNS Information ===\n")
    
    # A records
    a_records = dns_data.get("A", {})
    f.write("A Records:\n")
    
    if "error" in a_records:
        f.write(f"  Error: {a_records['error']}\n")
    else:
        for record in a_records.get("records", []):
            f.write(f"  {record}\n")
    
    # AAAA records
    aaaa_records = dns_data.get("AAAA", {})
    f.write("\nAAAA Records:\n")
    
    if "error" in aaaa_records:
        f.write(f"  Error: {aaaa_records['error']}\n")
    else:
        for record in aaaa_records.get("records", []):
            f.write(f"  {record}\n")
    
    # MX records
    mx_records = dns_data.get("MX", {})
    f.write("\nMX Records:\n")
    
    if "error" in mx_records:
        f.write(f"  Error: {mx_records['error']}\n")
    else:
        for record in mx_records.get("records", []):
            if isinstance(record, dict):
                f.write(f"  {record.get('preference')} {record.get('exchange')}\n")
            else:
                f.write(f"  {record}\n")
    
    # NS records
    ns_records = dns_data.get("NS", {})
    f.write("\nNS Records:\n")
    
    if "error" in ns_records:
        f.write(f"  Error: {ns_records['error']}\n")
    else:
        for record in ns_records.get("records", []):
            f.write(f"  {record}\n")
    
    # TXT records
    txt_records = dns_data.get("TXT", {})
    f.write("\nTXT Records:\n")
    
    if "error" in txt_records:
        f.write(f"  Error: {txt_records['error']}\n")
    else:
        for record in txt_records.get("records", []):
            f.write(f"  {record}\n")
    
    # SOA records
    soa_records = dns_data.get("SOA", {})
    f.write("\nSOA Records:\n")
    
    if "error" in soa_records:
        f.write(f"  Error: {soa_records['error']}\n")
    else:
        for record in soa_records.get("records", []):
            if isinstance(record, dict):
                f.write(f"  MNAME: {record.get('mname')}\n")
                f.write(f"  RNAME: {record.get('rname')}\n")
                f.write(f"  Serial: {record.get('serial')}\n")
                f.write(f"  Refresh: {record.get('refresh')}\n")
                f.write(f"  Retry: {record.get('retry')}\n")
                f.write(f"  Expire: {record.get('expire')}\n")
                f.write(f"  Minimum: {record.get('minimum')}\n")
            else:
                f.write(f"  {record}\n")
    
    # Write geolocation information if available
    geo = data.get("geolocation", {})
    if geo:
        f.write("\n=== Geolocation Information ===\n")
        
        if "error" in geo:
            f.write(f"Error: {geo['error']}\n")
        else:
            f.write(f"City: {geo.get('city', 'N/A')}\n")
            f.write(f"Region: {geo.get('region', 'N/A')}\n")
            f.write(f"Country: {geo.get('country', 'N/A')}\n")
            f.write(f"Postal: {geo.get('postal', 'N/A')}\n")
            f.write(f"Latitude: {geo.get('latitude', 'N/A')}\n")
            f.write(f"Longitude: {geo.get('longitude', 'N/A')}\n")
            f.write(f"ASN: {geo.get('asn', 'N/A')}\n")
            f.write(f"Organization: {geo.get('org', 'N/A')}\n")
            f.write(f"Timezone: {geo.get('timezone', 'N/A')}\n")

def _write_email_results(f, data):
    """Write email results to a text file.
    
    Args:
        f (file): File object
        data (dict): Data to export
    """
    # Write verification information
    verification = data.get("verification", {})
    f.write("=== Email Verification ===\n")
    
    if verification:
        f.write(f"Format Valid: {verification.get('format_valid', False)}\n")
        f.write(f"Domain Exists: {verification.get('domain_exists', False)}\n")
        f.write(f"Has MX Records: {verification.get('has_mx_records', False)}\n")
    else:
        f.write("No verification data available\n")
    
    # Write domain information
    domain_info = data.get("domain_info", {})
    if domain_info:
        f.write("\n=== Domain Information ===\n")
        f.write(f"Domain: {domain_info.get('target', 'N/A')}\n")
        
        # Write WHOIS information
        whois_data = domain_info.get("whois", {})
        f.write("\nWHOIS Information:\n")
        
        if "error" in whois_data:
            f.write(f"Error: {whois_data['error']}\n")
        else:
            f.write(f"  Registrar: {whois_data.get('registrar', 'N/A')}\n")
            f.write(f"  Creation Date: {whois_data.get('creation_date', 'N/A')}\n")
            f.write(f"  Expiration Date: {whois_data.get('expiration_date', 'N/A')}\n")
            f.write(f"  Updated Date: {whois_data.get('updated_date', 'N/A')}\n")
        
        # Write DNS information (MX records only)
        dns_data = domain_info.get("dns", {})
        if dns_data:
            mx_records = dns_data.get("MX", {})
            f.write("\nMX Records:\n")
            
            if "error" in mx_records:
                f.write(f"  Error: {mx_records['error']}\n")
            else:
                for record in mx_records.get("records", []):
                    if isinstance(record, dict):
                        f.write(f"  {record.get('preference')} {record.get('exchange')}\n")
                    else:
                        f.write(f"  {record}\n")

def _export_to_csv(data, file_path):
    """Export data to a CSV file.
    
    Args:
        data (dict): Data to export
        file_path (str): Path to the output file
        
    Returns:
        bool: True if export successful, False otherwise
    """
    try:
        # Basic implementation for MVP - will be expanded in future versions
        with open(file_path, "w", newline="", encoding="utf-8") as csvfile:
            writer = csv.writer(csvfile)
            
            # Write header
            writer.writerow(["Key", "Value"])
            
            # Flatten and write data
            for key, value in _flatten_dict(data).items():
                writer.writerow([key, value])
            
            return True
    except Exception as e:
        logging.error(f"CSV export error: {e}")
        return False

def _export_to_json(data, file_path):
    """Export data to a JSON file.
    
    Args:
        data (dict): Data to export
        file_path (str): Path to the output file
        
    Returns:
        bool: True if export successful, False otherwise
    """
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
            return True
    except Exception as e:
        logging.error(f"JSON export error: {e}")
        return False

def _flatten_dict(d, parent_key="", sep="_"):
    """Flatten a nested dictionary.
    
    Args:
        d (dict): Dictionary to flatten
        parent_key (str): Parent key
        sep (str): Separator
        
    Returns:
        dict: Flattened dictionary
    """
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        
        if isinstance(v, dict):
            items.extend(_flatten_dict(v, new_key, sep).items())
        elif isinstance(v, list):
            if v and all(isinstance(i, dict) for i in v):
                for i, item in enumerate(v):
                    items.extend(_flatten_dict(item, f"{new_key}{sep}{i}", sep).items())
            else:
                items.append((new_key, ", ".join(map(str, v)) if v else ""))
        else:
            items.append((new_key, v))
    
    return dict(items)

def format_time_elapsed(start_time):
    """Format elapsed time.
    
    Args:
        start_time (float): Start time from time.time()
        
    Returns:
        str: Formatted elapsed time
    """
    elapsed = time.time() - start_time
    
    if elapsed < 1:
        return f"{elapsed*1000:.0f} ms"
    elif elapsed < 60:
        return f"{elapsed:.2f} seconds"
    else:
        minutes = int(elapsed // 60)
        seconds = elapsed % 60
        return f"{minutes} min {seconds:.2f} sec"

def sanitize_filename(filename):
    """Sanitize a filename by removing invalid characters.
    
    Args:
        filename (str): Filename to sanitize
        
    Returns:
        str: Sanitized filename
    """
    # Replace invalid characters with underscore
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    
    return filename

def human_readable_size(size_bytes):
    """Convert size in bytes to human-readable format.
    
    Args:
        size_bytes (int): Size in bytes
        
    Returns:
        str: Human-readable size
    """
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes/1024:.2f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes/(1024*1024):.2f} MB"
    else:
        return f"{size_bytes/(1024*1024*1024):.2f} GB" 